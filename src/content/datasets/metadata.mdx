---
title: Metadata
description: Understanding and managing dataset metadata in Xether AI
---

# Dataset Metadata

Dataset metadata provides comprehensive information about your datasets, including schema definitions, business context, and operational characteristics. This guide covers how to work with metadata effectively in Xether AI.

## Metadata Overview

### Types of Metadata

**System Metadata**
- Automatically generated by the platform
- Includes creation timestamps, version numbers, file sizes
- Used for operational management and tracking

**Business Metadata**
- User-defined business context and descriptions
- Includes ownership, data classification, usage policies
- Essential for data governance and compliance

**Technical Metadata**
- Schema definitions, data types, constraints
- Format specifications, encoding information
- Critical for data integration and processing

**Operational Metadata**
- Access patterns, usage statistics, quality metrics
- Performance characteristics, processing history
- Used for optimization and monitoring

## Metadata Structure

### Core Metadata Fields

```json
{
  "id": "ds_1234567890",
  "name": "customer-transactions",
  "description": "Customer transaction records with payment details",
  "schema": {
    "type": "struct",
    "fields": [...]
  },
  "tags": ["financial", "pii", "production"],
  "metadata": {
    "business": {
      "owner": "finance-team@company.com",
      "steward": "data-steward@company.com",
      "classification": "confidential",
      "retention_policy": "7_years",
      "business_purpose": "financial_analysis"
    },
    "technical": {
      "source_system": "payment_processor",
      "ingestion_method": "streaming",
      "update_frequency": "real_time",
      "data_format": "json",
      "compression": "gzip"
    },
    "operational": {
      "created_by": "pipeline_456",
      "last_modified_by": "pipeline_789",
      "access_count": 1250,
      "last_accessed": "2024-01-20T10:30:00Z",
      "quality_score": 0.95
    }
  },
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-20T14:22:00Z",
  "version": 3,
  "status": "active"
}
```

## Schema Metadata

### Schema Definition

```json
{
  "type": "struct",
  "fields": [
    {
      "name": "transaction_id",
      "type": "string",
      "nullable": false,
      "description": "Unique identifier for the transaction",
      "constraints": {
        "pattern": "^[A-Z0-9]{16}$",
        "unique": true,
        "primary_key": true
      },
      "tags": ["identifier", "required"]
    },
    {
      "name": "customer_id",
      "type": "string",
      "nullable": false,
      "description": "Customer identifier",
      "constraints": {
        "pattern": "^[A-Z0-9]{10}$",
        "foreign_key": "customers.customer_id"
      },
      "tags": ["identifier", "pii"]
    },
    {
      "name": "amount",
      "type": "decimal",
      "nullable": false,
      "description": "Transaction amount in USD",
      "constraints": {
        "min": 0.01,
        "max": 999999.99,
        "precision": 10,
        "scale": 2
      },
      "tags": ["financial", "required"]
    },
    {
      "name": "currency",
      "type": "string",
      "nullable": false,
      "description": "Currency code",
      "constraints": {
        "values": ["USD", "EUR", "GBP", "JPY"],
        "default": "USD"
      },
      "tags": ["financial", "required"]
    },
    {
      "name": "transaction_date",
      "type": "timestamp",
      "nullable": false,
      "description": "Transaction timestamp",
      "constraints": {
        "timezone": "UTC",
        "format": "yyyy-MM-dd HH:mm:ss"
      },
      "tags": ["temporal", "required"]
    }
  ]
}
```

### Schema Evolution

```yaml
# Schema evolution example
original_schema:
  type: "struct"
  fields:
    - name: "customer_id"
      type: "string"
      nullable: false
    - name: "amount"
      type: "decimal"
      nullable: false

evolved_schema:
  type: "struct"
  fields:
    - name: "customer_id"
      type: "string"
      nullable: false
      description: "Added description field"
    - name: "amount"
      type: "decimal"
      nullable: false
      constraints:
        min: 0.01  # Added constraint
    - name: "currency"  # New field
      type: "string"
      nullable: false
      default: "USD"
    - name: "transaction_type"  # New field
      type: "string"
      nullable: true
```

## Business Metadata

### Ownership and Governance

```json
{
  "business": {
    "owner": {
      "name": "Finance Team",
      "email": "finance-team@company.com",
      "department": "Finance",
      "contact": "john.doe@company.com"
    },
    "steward": {
      "name": "Data Steward",
      "email": "data-steward@company.com",
      "responsibilities": ["quality_assurance", "access_control", "compliance"]
    },
    "classification": {
      "level": "confidential",
      "categories": ["financial_data", "pii"],
      "compliance": ["gdpr", "pci_dss", "sox"],
      "access_restrictions": ["finance_team_only", "auditor_access"]
    },
    "retention": {
      "policy": "7_years",
      "reason": "regulatory_compliance",
      "auto_delete": true,
      "archive_after": "5_years"
    },
    "purpose": {
      "primary": "financial_reporting",
      "secondary": ["fraud_detection", "customer_analytics"],
      "business_value": "high"
    }
  }
}
```

### Data Quality Metadata

```json
{
  "quality": {
    "completeness": {
      "overall_score": 0.95,
      "field_scores": {
        "transaction_id": 1.0,
        "customer_id": 0.98,
        "amount": 0.99,
        "currency": 0.95,
        "transaction_date": 0.97
      },
      "missing_value_threshold": 0.05
    },
    "accuracy": {
      "overall_score": 0.92,
      "validation_rules": [
        {
          "rule": "amount_positive",
          "pass_rate": 0.99
        },
        {
          "rule": "valid_currency",
          "pass_rate": 0.95
        },
        {
          "rule": "date_format_valid",
          "pass_rate": 0.98
        }
      ]
    },
    "consistency": {
      "overall_score": 0.89,
      "cross_field_checks": [
        {
          "check": "currency_matches_amount",
          "pass_rate": 0.92
        },
        {
          "check": "date_within_business_hours",
          "pass_rate": 0.85
        }
      ]
    },
    "timeliness": {
      "data_freshness_hours": 0.5,
      "update_frequency": "real_time",
      "lag_tolerance_minutes": 5,
      "last_update": "2024-01-20T14:22:00Z"
    }
  }
}
```

## Technical Metadata

### Source System Information

```json
{
  "source": {
    "system": "payment_processor",
    "type": "external_api",
    "connection": {
      "endpoint": "https://api.payment-processor.com/v1/transactions",
      "authentication": "oauth2",
      "rate_limit": "1000/minute"
    },
    "extraction": {
      "method": "streaming",
      "format": "json",
      "compression": "gzip",
      "encoding": "utf-8"
    },
    "reliability": {
      "uptime_sla": "99.9%",
      "error_rate": 0.001,
      "retry_policy": "exponential_backoff"
    }
  }
}
```

### Processing Information

```json
{
  "processing": {
    "ingestion": {
      "pipeline_id": "pipeline_123",
      "stage_name": "load_transactions",
      "processing_time_seconds": 45,
      "records_processed": 50000,
      "error_count": 2
    },
    "transformation": {
      "pipeline_id": "pipeline_456",
      "stages": [
        {
          "name": "validate_format",
          "processing_time_seconds": 12,
          "records_validated": 50000
        },
        {
          "name": "enrich_data",
          "processing_time_seconds": 28,
          "records_enriched": 49850
        }
      ]
    },
    "storage": {
      "format": "parquet",
      "compression": "snappy",
      "partitioning": ["year", "month", "day"],
      "location": "s3://data-lake/transactions/",
      "size_bytes": 104857600,
      "file_count": 24
    }
  }
}
```

## Operational Metadata

### Access and Usage

```json
{
  "access": {
    "total_accesses": 1250,
    "unique_users": 45,
    "access_patterns": {
      "daily_average": 50,
      "peak_hour": "14:00",
      "most_accessed_fields": ["amount", "customer_id", "transaction_date"]
    },
    "permissions": {
      "read": ["finance_team", "data_analysts", "auditors"],
      "write": ["finance_team"],
      "admin": ["data_engineers"]
    },
    "last_accessed": "2024-01-20T10:30:00Z",
    "popular_queries": [
      "SELECT customer_id, SUM(amount) GROUP BY customer_id",
      "SELECT * WHERE transaction_date >= '2024-01-01'",
      "SELECT COUNT(*) GROUP BY currency"
    ]
  }
}
```

### Performance Metrics

```json
{
  "performance": {
    "query_performance": {
      "avg_response_time_ms": 250,
      "p95_response_time_ms": 800,
      "p99_response_time_ms": 1500,
      "concurrent_queries_max": 25
    },
    "storage_performance": {
      "read_throughput_mbps": 150,
      "write_throughput_mbps": 100,
      "compression_ratio": 4.2,
      "cache_hit_rate": 0.85
    },
    "availability": {
      "uptime_percentage": 99.95,
      "last_downtime": "2024-01-10T03:15:00Z",
      "downtime_duration_minutes": 15
    }
  }
}
```

## Managing Metadata

### Creating Metadata

```python
# Python SDK example
import xether_ai

client = xether_ai.Client(api_key="your-api-key")

# Create dataset with comprehensive metadata
dataset = client.datasets.create(
    name="customer-transactions",
    description="Customer transaction records with payment details",
    schema={
        "type": "struct",
        "fields": [
            {
                "name": "transaction_id",
                "type": "string",
                "nullable": False,
                "description": "Unique transaction identifier",
                "constraints": {
                    "pattern": "^[A-Z0-9]{16}$",
                    "unique": True
                }
            },
            {
                "name": "amount",
                "type": "decimal",
                "nullable": False,
                "description": "Transaction amount",
                "constraints": {
                    "min": 0.01,
                    "max": 999999.99
                }
            }
        ]
    },
    tags=["financial", "pii", "production"],
    metadata={
        "business": {
            "owner": "finance-team@company.com",
            "classification": "confidential",
            "retention_policy": "7_years"
        },
        "technical": {
            "source_system": "payment_processor",
            "data_format": "json"
        }
    }
)
```

### Updating Metadata

```python
# Update metadata
dataset = client.datasets.update(
    "ds_1234567890",
    description="Updated description",
    tags=["financial", "pii", "production", "enhanced"],
    metadata={
        "business": {
            "owner": "enhanced-finance-team@company.com",
            "classification": "confidential",
            "retention_policy": "10_years"  # Updated retention
        },
        "quality": {
            "completeness_score": 0.96,
            "accuracy_score": 0.94
        }
    }
)
```

### Querying Metadata

```python
# Search datasets by metadata
datasets = client.datasets.list(
    tag="financial",
    metadata_filter={
        "business.classification": "confidential",
        "quality.completeness_score__gt": 0.9
    }
)

# Get detailed metadata
dataset = client.datasets.get("ds_1234567890", include_metadata=True)
print(f"Owner: {dataset.metadata['business']['owner']}")
print(f"Quality Score: {dataset.metadata['quality']['completeness_score']}")
```

## Metadata Templates

### Financial Data Template

```json
{
  "template_name": "financial_data",
  "description": "Template for financial datasets",
  "metadata_template": {
    "business": {
      "classification": "confidential",
      "compliance": ["pci_dss", "sox", "gdpr"],
      "retention_policy": "7_years",
      "access_restrictions": ["finance_team_only"]
    },
    "quality": {
      "completeness_threshold": 0.95,
      "accuracy_threshold": 0.98,
      "timeliness_hours": 24
    },
    "technical": {
      "encryption_required": true,
      "audit_logging": true,
      "backup_frequency": "daily"
    }
  }
}
```

### PII Data Template

```json
{
  "template_name": "pii_data",
  "description": "Template for personally identifiable information",
  "metadata_template": {
    "business": {
      "classification": "restricted",
      "compliance": ["gdpr", "ccpa", "hipaa"],
      "retention_policy": "2_years",
      "anonymization_required": true
    },
    "privacy": {
      "data_subject_rights": ["access", "rectification", "erasure"],
      "consent_required": true,
      "data_minimization": true
    },
    "security": {
      "encryption_at_rest": true,
      "encryption_in_transit": true,
      "access_logging": true,
      "role_based_access": true
    }
  }
}
```

## Metadata Governance

### Metadata Standards

### Field Naming Conventions

```yaml
naming_conventions:
  field_names:
    format: "snake_case"
    max_length: 64
    allowed_characters: "a-z0-9_"
    reserved_words: ["order", "group", "user"]
  
  descriptions:
    required: true
    max_length: 255
    format: "sentence_case"
  
  tags:
    format: "lowercase"
    separator: "_"
    max_tags_per_field: 5
    standard_tags: ["pii", "financial", "temporal", "identifier"]
```

### Metadata Validation Rules

```yaml
validation_rules:
  required_fields:
    - "name"
    - "description"
    - "schema"
    - "business.owner"
    - "business.classification"
  
  schema_validation:
    - all_fields_must_have_types
    - nullable_fields_must_have_defaults
    - primary_key_fields_must_be_non_nullable
  
  business_validation:
    - owner_must_be_valid_email
    - classification_must_be_approved
    - retention_policy_must_comply_with_regulations
```

### Metadata Change Management

```yaml
change_management:
  approval_required_for:
    - schema_changes
    - classification_changes
    - retention_policy_changes
    - access_permission_changes
  
  change_types:
    - minor_update: "Description changes, tag additions"
    - major_update: "Schema changes, metadata structure changes"
    - breaking_change: "Field removals, type changes"
  
  notification_rules:
    - notify_owner_on_any_change
    - notify_steward_on_major_changes
    - notify_security_team_on_classification_changes
```

## Metadata Analytics

### Usage Analytics

```python
# Analyze metadata usage
usage_stats = client.datasets.get_usage_statistics(
    dataset_id="ds_1234567890",
    time_range="30d"
)

print(f"Total accesses: {usage_stats.total_accesses}")
print(f"Unique users: {usage_stats.unique_users}")
print(f"Most accessed fields: {usage_stats.popular_fields}")
```

### Quality Analytics

```python
# Analyze data quality trends
quality_trends = client.datasets.get_quality_trends(
    dataset_id="ds_1234567890",
    time_range="90d"
)

for metric in quality_trends:
    print(f"{metric.name}: {metric.current_score} (trend: {metric.trend})")
```

### Metadata Search

```python
# Advanced metadata search
results = client.datasets.search(
    query="financial transactions",
    filters={
        "tags": ["production"],
        "metadata.business.classification": "confidential",
        "metadata.quality.completeness_score__gt": 0.9
    },
    sort_by="metadata.access.total_accesses",
    order="desc"
)
```

## Best Practices

### Metadata Management

1. **Be Comprehensive**: Include all relevant metadata fields
2. **Keep Current**: Update metadata when data changes
3. **Use Standards**: Follow naming conventions and templates
4. **Document Everything**: Provide clear descriptions and context
5. **Validate Regularly**: Ensure metadata accuracy and completeness

### Schema Design

1. **Use Appropriate Types**: Choose data types that match the data
2. **Add Constraints**: Define validation rules and constraints
3. **Document Fields**: Provide clear descriptions for all fields
4. **Plan for Evolution**: Design schemas that can evolve gracefully
5. **Test Validation**: Ensure schema validation works correctly

### Governance

1. **Define Ownership**: Clearly assign data owners and stewards
2. **Classify Data**: Apply appropriate classification levels
3. **Set Retention**: Define retention policies based on regulations
4. **Monitor Access**: Track who accesses data and when
5. **Audit Changes**: Maintain audit trails for metadata changes

## Troubleshooting

### Common Issues

#### Missing Metadata
```python
# Check for missing required metadata
dataset = client.datasets.get("ds_1234567890")
required_fields = ["name", "description", "schema", "business.owner"]

missing_fields = []
for field in required_fields:
    if not hasattr(dataset.metadata, field):
        missing_fields.append(field)

if missing_fields:
    print(f"Missing required fields: {missing_fields}")
```

#### Schema Validation Errors
```python
# Validate schema before updating
try:
    client.datasets.validate_schema(new_schema)
    client.datasets.update("ds_1234567890", schema=new_schema)
except SchemaValidationError as e:
    print(f"Schema validation failed: {e}")
```

#### Metadata Conflicts
```python
# Resolve metadata conflicts
conflicts = client.datasets.detect_conflicts("ds_1234567890")
for conflict in conflicts:
    print(f"Conflict in {conflict.field}: {conflict.description}")
    # Resolve conflict based on business rules
```

This comprehensive metadata guide provides everything needed to effectively manage dataset metadata in Xether AI, from basic concepts to advanced governance and analytics.
